# Reliable UDP

# 1 개요

1. 수신측에서 중간에 빠진 패킷을 송신측에게 요청한다.
2. 수신측에서 받은 패킷에 대한 정보를 송신측에게 알려준다.

# 2 구현

1. 다른 피어에게 보낸 데이터그램의 리스트 관리 기능 - 인증을 받기 전에는 송신한 데이터그램을 삭제하지 말고, 가지고 있어야한다.
2. 수신측이 송신측에게 데이터그램을 무사히 받았다고 알려주는 기능
3. 무사히 받았다고 수신 측이 알려왔을 때, 송신측에서 해당하는 데이터그램을 삭제할 수 있는 기능
4. 데이터그램이 도착했을 때, 데이터그램이 이미 실행한 것인지의 여부를 판단할 수 있는 기능
5. 순서를 건너뛴 데이터그램이 도착했을 때, 빠진 데이터그램을 기억해두는 기능

```cpp
class UDPPeerState
{
    // IP + PORT의 문자열 값으로서 피어를 구분하는 역할을 한다.
    string m_PeerKey;

    // 받아서 실행한 데이터그램 중 제일 값이 큰 것
    DatagramID_t LastID;

    // 데이터그램이 순서대로 오지 않고, 건너뛴 경우...
    // 즉 11번 데이터그램 다음에 13번 데이터그램이 왔다 같은 경우,
    // "12번이 빠졌다"라는 정보를 기억하기 위한 리스트
    list<Datagram> OmittedList;

    // 무사히 실행한 데이터그램의 리스트
    // 나중에 송신측에게 무사히 실행했다는 사실을 기록한 데이터그램을 날려줄 때 쓰인다.
    list<Datagram> AckList;
}

```

## 2.1 데이터그램을 보낼 때 해야할 일

1. 데이터그램의 ID를 부여한다. 이는 보낼 때마다 +1씩 증가시키는 방법으로 처리하면 된다.
2. 데이터그램을 보낸다.
3. 데이터그램에 대한 인증을 받지 못했을 경우, 다음에 전송해야하는 시간을 기록해둔다.
4. 데이터그램에 대한 인증을 받지 못했을 경우, 전송을 시도할 최대 횟수를 기록해둔다.
5. 데이터그램을 **보냈지만, 아직 인증받지 못한 데이터그램의 리스트**에다가 집어넣어둔다.

## 2.2 데이터그램을 받았을 때 해야할 일

1. 데이터그램이 이미 한번 실행했던 데이터그램이 아닌지 검사한다. 이는 **중간에 빠진 데이터그램의 리스트**와 **현재까지 도착한 데이터그램ID의 최대값**을 이용해서 이루어진다.
2. 이미 한번 실행했던 것이라면 그냥 무시하고, 아니라면 정상적으로 실행한다.
3. **현재까지 도착한 데이터그램ID의 최대값**과 **중간에 빠진 데이터그램의 리스트**를 갱신한다.
4. 데이터그램을 "정상적으로 실행했지만, 송신측에 알려주지 않은 리스트"에다가 등록한다.
5. 만일 데이터그램이 수신측이 보내온 인증 데이터그램이라면 **보냈지만, 아직 인증받지 못한 데이터그램의 리스트**에 있는 해당하는 데이터그램들을 삭제해준다.

## 2.3 주기적으로 처리해야할 일

1. **정상적으로 실행했지만, 송신측에 알려주지 않은 리스트**에 데이터그램ID가 들어있다면 이를 송신측에게 송신한다. (이 데이터그램 역시 데이터그램을 보내는 것이므로, 데이터그램을 보낼 때 해야할 일들을 차례로 수행한다.)
2. **보냈지만, 아직 인증받지 못한 데이터그램의 리스트**를 검색하면서 재전송해야하는 데이터그램이 있다면 재전송한다. (재전송할 때마다 다음에 전송해야하는 시간과 전송 시도 횟수를 갱신해야한다.)
3. 최대 재전송 횟수를 초과한 데이터그램은 삭제해버린다. (끝까지 전송되지 않는 데이터그램이 결국 생길 수 있다.)

## 2.4 빠진 데이터그램인지 확인하는 방법

1. **10 11 12** : 모든 것이 순서대로 왔다. LastID는 매번 증가한다.
2. **11 10 12** : 먼저 LastID가 11로 증가한다. 9->11로 변했으므로, 10의 값이 **중간에 빠진 데이터그램의 리스트**에 추가된다. 다음으로 10이 오면 리스트에 존재하므로, 실행한다. 그리고 리스트에서 데이터를 삭제한다. 12는... 정상적이므로 실행한다.
3. **10 10 11** : 제일 처음 오는 10은 당연히 정상적으로 실행된다. 두번째로 오는 10은 LastID값에 의해서 무시된다. 11은 다시 정상적으로 실행된다.

```cpp
bool UDPPeerState::validateDatagramID(DatagramID_t ID)
{ 
// 만일 데이터그램의 ID가 마지막으로 실행한 데이터그램의 ID보다 작다면,
 // 혹시 이전에 빠진 데이터그램인지 검사해본다. 
	if (ID < m_pImpl->LastID) 
	{ 
			list<OMIT_INFO>::iterator itr = m_pImpl->OmitList.begin(); 
			for (; itr != m_pImpl->OmitList.end(); itr++) 
			{ 
					if (ID == (*itr).ID) 
					{ 
					// 이전에 빠진 데이터그램이라면 실행해야 한다. 
					return true;
					}
			}
	} 
// 새로운 데이터그램이다.
 else if (ID > m_pImpl->LastID)
	{ 
// 어쨌든 true다. return true; 
	} 
// 이까지 왔다는 말은 데이터그램의 ID가 마지막으로 받은 데이터그램의
 // ID와 같다는 말이므로, 무시해야 한다.
 return false;
}
```

# 3 예외 처리

## * PEER 중 어느 한쪽이 비정상적으로 종료된 경우

통신을 하고 있던 양쪽 중에서 어느 한쪽이 죽었다고 하자. 이런 경우 생기는 문제는 두 가지로 나눌 수 있다.

## * 죽은 PEER가 상당 시간 계속 죽어있는 경우

이 경우의 문제는 죽은 쪽에서 인증 패킷을 보내주지 않음으로 인해, 송신 측에서 패킷을 계속 재 전송 하는 데 있다. 이 문제는 재 전송의 횟수에 제한을 줌으로서 해결할 수 있다. 물론 둘 다 살아있는데도 불구하고, 재 전송 최대 횟수 만큼의 송신이 실패할 우려(예를 들어 15번을 최대 재 전송 횟수로 잡았는데, 15번 모두 실패!)도 있겠지만, 확률은 상당히 낮다고 본다.

## * 죽은 PEER가 다시 살아난 경우

이 경우 죽은 PEER는 보내는 데이터그램의 ID를 초기값부터 보내온다. 즉 수신 측에서 유지하고 있던 인증 정보가 완전히 쓸모없어져 버리는 것이다. 이런 경우 수신 측은 송신 측에 맞춰서 인증 관련 정보를 초기화해줘야한다. 이것을 위해서 송신측에서는 임의의 PEER에게 패킷을 보낼 경우, 해당하는 PEER에게 패킷을 보낸 적이 있는지 조사하고 보낸 적이 없다면, 수신 측에게 인증 관련 정보를 초기화하라는 패킷을 보내 준 후에 실제 패킷을 날려야한다.